Application support
===================

The zc.extjs.application module provides support for writing ajax
[#ajax]_ applications.  This framework started out as an experiment in
simplifying writing applications with Zope 3.  I was frustrated with
ZCML situps and generally too much indirection.  I ended up with a
model that I'm pretty happy with.  It might not be for everybody. :)

The basic idea is that an application can be provided using a single
Zope 3 view plus necessary resource-library definitions.  This view
has a URL.  It typically provides many ajax methods whose URLs have the
view URL as a base.

Many applications can be implemented using a simple class that can be
registered as a view.

Let's look at a simple stupid application. :)

.. include:: calculator_example.py
   :literal:

We subclass zc.extjs.application.Trusted. This is a minimal
base class that provides a constructor that takes a context and a
request and removes the security proxy from the context.  It
overrides the constructor from zc.extjs.application.Application.

We also subclass zc.extjs.application.Application.  This is a base
class that provides:

- a basic constructor that takes context and request arguments and sets
  corresponding attributes,

- traversal to attributes that provide IBrowserPublisher with
  conversion of dots to underscores,

- a default "page" named index.html,

- a template method that returns an HTML page with an empty head.

- an index_html method that loads a resource library and calls the
  template,

- an interface declaration that it provides IBrowserPublisher, and

- an adapter declaration that adapts
  zope.traversing.interfaces.IContainmentRoot and
  zope.publisher.interfaces.browser.IBrowserRequest.

The main goals of this base class are to make it easy to load
Javascript and to make it easy to define ajax methods to support the
Javascript. For that reason, we provide a traverser that traverses to
object attributes that provide IBrowserPublisher.  The
zc.extjs.application.jsonpage decorator is also an important part of
this. It makes methods accessible and automatically marshals their
result to JSON [#jsoninput]_.  There's also a
zc.extjs.application.page decorator that makes methods accessable
without the automatic marshalling.  The use of a default page, rather
than just a __call__ method is to cause the URL base to be the view,
rather than the view's context.  This allows the Javascript code to
use relative URLs to refer to the ajax methods.

The class expects subclasses to define a resource_library_name
attribute [#missing_resource_library_name]_.  For these applications,
you pretty much always want to use an associated Javascript file and
other resources (supporting JS, CSS, etc.).  You can suppress the use
of the resource library by setting the value of this attribute to
None. In the example above, we just used zc.extjs.  We'd normally
create a custom resource library that required zc.extjs and use that.

For applications that build pages totally in Javascript, which ExtJS
makes easy to do, the default template is adequate.  For applications
that need to support non-Javascript-enabled browsers, that want to
support search-engine optimization [#sso]_, or that want to
provide some Javascript data during the initial page load, a custom
template can be provided by simply overriding the template method with
a page template or a method that calls one.

The view can be registered with a simple adapter registration:

.. include:: calculator_example.zcml
   :literal:

If we wanted to register it for an object other than the an
IContainmentRoot, we could just provide specificy adapted interfaces
or classes in the registration.

Let's access the calculator with a test browser

    >>> import zope.testbrowser.testing
    >>> browser = zope.testbrowser.testing.Browser()
    >>> browser.open('http://localhost/')
    Traceback (most recent call last):
    ...
    httperror_seek_wrapper: HTTP Error 401: Unauthorized

Because our view was registered to require zope.View, the request was
unauthorized.  Let's login:

    >>> browser.addHeader('Authorization', 'Basic bob:123')
    >>> browser.open('http://localhost/calculator.html')
    >>> print browser.contents
    <html><head>
    <base href="http://localhost/calculator.html/index.html" />
    <BLANKLINE>
        <script src="http://localhost/@@/Ext/adapter/yui/yui-utilities.js" 
            type="text/javascript">
        </script>
        <script src="http://localhost/@@/Ext/adapter/yui/ext-yui-adapter.js" 
            type="text/javascript">
        </script>
        <script src="http://localhost/@@/Ext/ext-all.js" 
            type="text/javascript">
        </script>
        <script src="http://localhost/@@/Ext/set_blank_image.js" 
            type="text/javascript">
        </script>
        <style type="text/css" media="all">
          <!--
            @import url("http://localhost/@@/Ext/resources/css/ext-all.css");
          -->
        </style>
        <script src="http://localhost/@@/zc.extjs/util.js" 
            type="text/javascript">
        </script>
        <script src="http://localhost/@@/zc.extjs/widgets.js" 
            type="text/javascript">
        </script>
        <style type="text/css" media="all">
          <!--
            @import url("http://localhost/@@/zc.extjs/util.css");
          -->
        </style>
    </head></html>

We registered our view as calculator.html. Because of the way it sets the
browser default page for itself, it becomes the base href for the
page.  This allows us to access ajax methods using relative URLs.

Our calculator view provides a value method.  It uses the
zc.extjs.application.jsonpage decorator. This does 2 things:

- Arranges that the method can be traversed to,

- marshals the result to JSON.

The way results are marshalled to JSON deserves some
explanation. ExtJS generally expects objects to be returned from ajax
calls.  The ExtJS form framework expects results to have a success
property indicating whether a form was successfully processed. If
success is false, it also expects an errors property that is an object
mapping field names to errors to be displayed with error fields.  The
zc.extjs packge provides an ajax helper, named call_server that follows a
similar convention.  If a result has a false success propery and an
error property containing an error message, it displays an alert with
the error message.  There's also a form helper that displays an alert
if there is an error message.  The marshaller used by the
zc.extjs.application.jsonpage decorator adds a success property if a
dictionary is returned that doesn't have one.  The property is true
unless there are error or errors properties.  

    >>> browser.open('http://localhost/@@calculator.html/value')
    >>> print browser.contents
    {"success": true, "value": 0}

    >>> browser.open('http://localhost/@@calculator.html/add?value=hi')
    >>> print browser.contents
    {"success": false, "error": "The value must be an integer!"}

Also, if a method returns None, an object with a true success property
is returned:

    >>> browser.open('http://localhost/@@calculator.html/noop')
    >>> print browser.contents
    {"success": true}

If something other than a dictionary is returened from a Python
method, no success attribute is added:

    >>> browser.open('http://localhost/@@calculator.html/about')
    >>> print browser.contents
    "Calculator 1.0"

    >>> browser.open('http://localhost/@@calculator.html/operations')
    >>> print browser.contents
    ["add", "subtract"]

If you want to marshal JSON yourself, you can use the
zc.extjs.application.jsonpage decorator:

    >>> browser.open('http://localhost/@@calculator.html/none')

An alternative way to return errors is to raise user errors, as is
done by the subtract method in our example:

    >>> browser.open('http://localhost/@@calculator.html/subtract?value=hi')
    >>> print browser.contents
    {"success": false, "error": "The value must be an integer!"}

This works because there is a view registered for
zope.exceptions.interfaces.IUserError, and
zc.extjs.interfaces.IAjaxRequest.

Testing support
===============

zc.extjs.testing has some helper functions to make it easier to test
ajax calls.  

The call_form function makes an ajax call, marshaling input data and
de-marshaling output data. It's called call_form because it marshals
input data as form variables.  Data can be given as a dictionary
positional argument or as keyword parameters:

    >>> from zc.extjs.testing import call_form, print_form
    >>> from pprint import pprint
    >>> pprint(call_form(browser, '/calculator.html/add',
    ...        {'value': 1}), width=1)
    {u'success': True,
     u'value': 1}

    >>> pprint(call_form(browser, '/calculator.html/add', value=1), width=1)
    {u'success': True,
     u'value': 2}

The methods called are assumed to return JSON and the resulting data
is converted back into Python.

The first two arguments are a test browser and a URL.

Keyword arguments are convenient, but sometimes, we need to pass form
data whose keys are not valid Python identifiers.

Data can be unicode, strings, integers, floats, boolean, or lists. 

    >>> pprint(call_form(browser, '/calculator.html/echo_form',
    ...                  {'a': 1.0}, b=[1, 2, 3], c=True, d='d', e=u'e\u1234'
    ...        ), width=1)
    {u'a': 1.0,
     u'b': [1,
            2,
            3],
     u'c': True,
     u'd': u'd',
     u'e': u'e\u1234',
     u'success': True}

The function print_form combines pprint and call_form:

    >>> print_form(browser, '/calculator.html/add', {'value': 1})
    {u'success': True,
     u'value': 3}

    >>> print_form(browser, '/calculator.html/add', value=1)
    {u'success': True,
     u'value': 4}

    >>> print_form(browser, '/calculator.html/echo_form',
    ...            {'a': 1.0}, b=[1, 2, 3], c=True, d='d', e=u'e\u1234'
    ...            )
    {u'a': 1.0,
     u'b': [1,
            2,
            3],
     u'c': True,
     u'd': u'd',
     u'e': u'e\u1234',
     u'success': True}

In the future, there will be versions of these functions that send
data as JSON.

.. Edge case: we can't traverse to undecorated methods:

    >>> print_form(browser, '/calculator.html/do_add', value=1)
    Traceback (most recent call last):
    ...
    httperror_seek_wrapper: HTTP Error 404: Not Found


"Library" applications
======================

The "application" model described above is pretty appealing in it's
simplicity -- at least to me. :)  Usually, we'd like to make out
applications a bit more flexible in their use.  In particular, we
often want to assemble applications together. At the Javascript level,
this often means having an application return a panel that can be used
in some higher-level layout.  At the server level, we need to provide
a way to access application logic within some larger context.  There
are two parts to this:

1. The containing application needs to support traversal to the
   sub-application.  

2. The subapplication needs to know how it was traversed to, at least
   if it generates URLs.  For example, the form machinery [#forms]_
   generates URLs for action handlers.

Sub-application should expose the URL needed to access then as a
base_href attribute. This is usually a relative URL relative to the base
application. 

There are a number of classes defined in zc.extjs.application that
help with creating sub-applications:

SubApplication
    This class, which Application subclasses provides traversal to
    attributes that provide IBrowserPublisher.  It also stamps
    IAjaxRequest on the request object when an object is traversed.

    (Maybe this request stamping should be done further down the
    traversal chain or perhaps only done if X-Requested-With is
    xmlhttprequest.)

PublicTraversable
    This class provides security declarations that allow objects to be
    traversable publically.  This is appropriate for sub-applications
    that want the same protections as the object being traversed.

Let's look at our calculator example as a subapplication:

.. include:: calculator_subapplication_example.py
   :literal:

Here, we've defined a container application that simply provides
traversal to a calculator subapplication as a static property.  It
creates the calculator with the application's context and request.  It
passes a base_href as a keyword argument, which SubApplication's
constructor accepts.  Our ZCML configuration is pretty simple:

.. include:: calculator_subapplication_example.zcml
   :literal:

Using the container application, we access the calculator via the
container:

    >>> print_form(browser, 'http://localhost/@@container.html/calc/add',
    ...            value=1)
    {u'success': True,
     u'value': 5}

We've updated the operations method to include the URL for each
operation, which is computed based on the base_href:

    >>> print_form(browser, 'http://localhost/@@container.html/calc/operations')
    [[u'add',
      u'calc/add'],
     [u'add',
      u'calc/subtract']]


Note that we didn't make any security declarations for the Calculator
class.  We're relying on the protection for the container.  If we
restart the browser, we see, indeed, that we can't access the
calculator:

    >>> browser = zope.testbrowser.testing.Browser()
    >>> print_form(browser, 'http://localhost/@@container.html/calc/operations')
    {u'session_expired': True,
     u'success': False}

Dynamic Traversal
=================

In the previous example, we traversed to a sub-application using a
static property.  Sometimes, we need to traverse dynamically.  We
might have a container application with a variable number of
subapplications. Examples include a portlet container and a system for
managing user-defined data types.  In the later case, as users define
new data types, one or more applications get defined for each type.

zc.extjs.application provides a helper descriptor that allows custom
traversers to be implemented with simple Python methods.  Let's look
at a simple example.

    >>> import zc.extjs.application   
    >>> class Foo:
    ...     def __str__(self):
    ...         return 'a '+self.__class__.__name__
    ...
    ...     @zc.extjs.application.traverser
    ...     def demo_traverse(self, request, name):
    ...         return "traverse: %s %s %s" % (self, request, name)

This is a rather silly traverser for demonstration purposes that just
returnes a transformed name.

    >>> foo = Foo()
    >>> foo.demo_traverse.publishTraverse("a request", "xxx")
    'traverse: a Foo a request xxx'

We can still call the method:

    >>> foo.demo_traverse("a request", "xxx")
    'traverse: a Foo a request xxx'

The method provides IBrowserPublisher:

    >>> import zope.publisher.interfaces.browser
    >>> zope.publisher.interfaces.browser.IBrowserPublisher.providedBy(
    ...     foo.demo_traverse)
    True

The descriptor has a security declaration that allows it to be
traversed but not called from untrusted code:

    >>> import zope.security.checker
    >>> checker = zope.security.checker.getChecker(
    ...     zope.security.checker.ProxyFactory(foo.demo_traverse))
    >>> checker.get_permissions
    {'publishTraverse': Global(CheckerPublic,zope.security.checker)}

    >>> checker.set_permissions
    {}


.. [#ajax] Technically, these aren't really AJAX applications, since
   we rarely. if ever, use XML as a serialization format.  To
   emphasize this I'll use lower-case "ajax" to refer to the generic
   approach of making low-level calls from Javascript rather than
   doing page loads.

.. [#jsoninput] In the near future, there will also be support for
   JSON method input.  This will provide a number of benefits:

   - It will provide more automatic marshaling of non-string
     data. Now, we either have to de-marshal in the server application
     code or embed marshaling data into parameter names in client
     code.

   - It will allow richer data structures than is practical with form data.

   - It will probably allow faster ajax requests because:

     - Server-side de-marshalling is done with highly optimized code
       in simplejson.

     - We will assume that data passed are valid method arguments and
       avoid method introspection.

.. [#missing_resource_library_name] A custom attribute error message
   is used if this attribute is missing that tries to be more
   informative than the default attribute error.

.. [#sso]  For search-engine optimization, one generally wants a
   content page to actuially contain it's content.  If one depends on
   Javascript-enabled browsers, one can improve performance and
   search-engine optimization by adding ancilary data in Javascript,
   so as not to dilute the content.

.. [#forms] See form.txt.
