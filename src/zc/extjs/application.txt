Application support
===================

The zc.extjs.application module provides support for writing AJAX
[#ajax]_ applications.  This framework started out as an experiment in
simplifying writing applications with Zope 3.  I was frustrated with
ZCML situps and generally too much indirection.  I ended up with a
model that I'm pretty happy with.  It might not be for everybody. :)

The basic idea is that an application can be provided using a single
Zope 3 view plus necessary resource-library definitions.  This view
has a URL.  It typically provides many AJAX method whose URLs have the
view URL as a base.

Many applications can be implemented using a simple class that can be
registered as a view.

Let's look at a simple stupid application. :)

.. include:: calculator_example.py
   :literal:

We subclass zc.extjs.application.Trusted. This is a minimal
base class that provides a constructor that takes a context and a
request and removes the security proxy from the context.  It
overrides the constructor from zc.extjs.application.Application.

We also subclass zc.extjs.application.Application.  This is a base
class that provides:

- a basic constructor that takes context and request arguments and sets
  corresponding attributes,

- traversal to attributes that provide IBrowserPublisher with
  conversion of dots to underscores,

- a default "page" named index.html,

- a template method that returns an HTML page with an empty head.

- an index_html method that loads a resource library and calls the
  template,

- an interface declaration that it provides IBrowserPublisher, and

- an adapter declaration that adapts
  zope.traversing.interfaces.IContainmentRoot and
  zope.publisher.interfaces.browser.IBrowserRequest.

The main goals of this base class are to make it easy to load
javascript and to make it easy to define Ajax methods to support the
Javascript. For that reason, we provide a traverser that traverses to
object attributes that provide IBrowserPublisher.  The
zc.extjs.application.jsonpage decorator is also an important part of
this. It makes methods accessible and automatically marshals their
result to JSON.  There's also a zc.extjs.application.page decorator
that makes methods accessable without the automatic marshalling.  The
use of a default page, rather than just a __call__ method is to cause
the URL base to be the view, rather than the view's context.  This
allows the Javascript code to use relative URLs to refer to the AJAX
methods.

The class expects subclasses to define a resource_library_name
attribute [#missing_resource_library_name]_.  For these applications,
you pretty much always want to use an associated Javascript file and
other resources (supporting JS, CSS, etc.).  You can suppress the use
of the resource library by setting the value to None. In the example
above, we just used zc.extjs.  We'd normally create a custom resource
library that required zc.extjs and use that.

For applications that build pages totally in Javascript, which ExtJS
makes easy to do, the default template is adequate for most
applications.  For applications that need to support
non-Javascript-enabled browsers or that want to provide some
Javascript data during the initial page load, a custom template can be
provided by simply overriding the template method with a page template
or a method that calls one.

The view can be registered with a simple adapter registration:

.. include:: calculator_example.zcml
   :literal:

If we wanted to register it for an object other than the an
IContainmentRoot, we could just provide specificy adapted interfaces
or classes in the registration.

Let's access the calculator with a test browser

    >>> import zope.testbrowser.testing
    >>> browser = zope.testbrowser.testing.Browser()
    >>> browser.open('http://localhost/')
    Traceback (most recent call last):
    ...
    httperror_seek_wrapper: HTTP Error 401: Unauthorized

Because our view was registered to require zope.View, the request was
unauthorized.  Let's login:

    >>> browser.addHeader('Authorization', 'Basic bob:123')
    >>> browser.open('http://localhost/calculator.html')
    >>> print browser.contents
    <html><head>
    <base href="http://localhost/calculator.html/index.html" />
    <BLANKLINE>
        <script src="http://localhost/@@/Ext/adapter/yui/yui-utilities.js" 
            type="text/javascript">
        </script>
        <script src="http://localhost/@@/Ext/adapter/yui/ext-yui-adapter.js" 
            type="text/javascript">
        </script>
        <script src="http://localhost/@@/Ext/ext-all.js" 
            type="text/javascript">
        </script>
        <script src="http://localhost/@@/Ext/set_blank_image.js" 
            type="text/javascript">
        </script>
        <style type="text/css" media="all">
          <!--
            @import url("http://localhost/@@/Ext/resources/css/ext-all.css");
          -->
        </style>
        <script src="http://localhost/@@/zc.extjs/util.js" 
            type="text/javascript">
        </script>
        <script src="http://localhost/@@/zc.extjs/widgets.js" 
            type="text/javascript">
        </script>
        <style type="text/css" media="all">
          <!--
            @import url("http://localhost/@@/zc.extjs/util.css");
          -->
        </style>
    </head></html>

We registered our view as calculator.html. Because of the way it sets the
browser default page for itself, it becomes the base href for the
page.  This allows us to access AJAX methods using relative URLs.

Our calculator view provides a value method.  It uses the
zc.extjs.application.jsonpage decorator. This does 2 things:

- Arranges that the method can be traversed to,

- marshals the result to JSON.

The way results are marshalled to JSON deserves some
explanation. ExtJS generally expects objects to be returned from Ajax
calls.  The ExtJS form framework expects results to have a success
property indicating whether a form was successfully processed. If
success is false, it also expects an errors property that is an object
mapping field names to errors to be displayed under each field.  The
zc.extjs packge provides an AJAX helper, named call_server that follows a
similar convention.  If a result has a false success propery and an
error property containing an error message, it displays an alert with
the error message.  There's also a form helper that displays an alert
if there is an error message.  The marshaller used by the
zc.extjs.application.jsonpage decorator adds a success property if a
dictionary is returned that doesn't have one.  The property is true
unless there are error or errors properties.  

    >>> browser.open('http://localhost/@@calculator.html/value')
    >>> print browser.contents
    {"success": true, "value": 0}

    >>> browser.open('http://localhost/@@calculator.html/add?value=hi')
    >>> print browser.contents
    {"success": false, "error": "The value must be an integer!"}

Also, if a method returns None, an object with a true success property
is returned:

    >>> browser.open('http://localhost/@@calculator.html/noop')
    >>> print browser.contents
    {"success": true}

If something other than a dictionary is returened from a Python
method, no success attribute is added:

    >>> browser.open('http://localhost/@@calculator.html/about')
    >>> print browser.contents
    "Calculator 1.0"

    >>> browser.open('http://localhost/@@calculator.html/operations')
    >>> print browser.contents
    ["add"]

If you want to marshal JSON yourself, you can use the
zc.extjs.application.jsonpage decorator:

    >>> browser.open('http://localhost/@@calculator.html/none')

An alternative way to return errors is to raise user errors, as is
done by the subtract method in our example:

    >>> browser.open('http://localhost/@@calculator.html/subtract?value=hi')
    >>> print browser.contents
    {"success": false, "error": "The value must be an integer!"}

This works because there is a view registered for
zope.exceptions.interfaces.IUserError, and
zc.extjs.interfaces.IAjaxRequest.

Testing support
===============

zc.extjs.testing has some helper functions to make it easier to test
AJAX calls.  

The call_form function makes an AJAX call, marshaling input data and
de-marshaling output data. It's called call_form because it marshals
input data as form variables.  Data can be given as a dictionary
positional argument or as keyword parameters:

    >>> import zc.extjs.testing
    >>> from pprint import pprint
    >>> pprint(zc.extjs.testing.call_form(browser, '/calculator.html/add',
    ...                                 {'value': 1}), width=1)
    {u'success': True,
     u'value': 1}

    >>> pprint(zc.extjs.testing.call_form(
    ...        browser, '/calculator.html/add', value=1),
    ...        width=1)
    {u'success': True,
     u'value': 2}

The methods called are assumed to return JSON and the resulting data
is converted back into Python.

The first two arguments are a test browser and a URL.

Keyword arguments are convenient, but sometimes, we need to pass form
data whose keys are not valid Python identifiers.

Data can be unicode, strings, integers, floats, boolean, or lists. 

    >>> browser.handleErrors = False
    >>> pprint(zc.extjs.testing.call_form(
    ...     browser, '/calculator.html/echo_form',
    ...     {'a': 1.0}, b=[1, 2, 3], c=True, d='d', e=u'e\u1234'
    ...     ), width=1)
    {u'a': 1.0,
     u'b': [1,
            2,
            3],
     u'c': True,
     u'd': u'd',
     u'e': u'e\u1234',
     u'success': True}

The function print_form combines pprint and call_form:

    >>> zc.extjs.testing.print_form(browser, '/calculator.html/add',
    ...                             {'value': 1})
    {u'success': True,
     u'value': 3}

    >>> zc.extjs.testing.print_form(browser, '/calculator.html/add', value=1)
    {u'success': True,
     u'value': 4}

    >>> zc.extjs.testing.print_form(
    ...     browser, '/calculator.html/echo_form',
    ...     {'a': 1.0}, b=[1, 2, 3], c=True, d='d', e=u'e\u1234'
    ...     )
    {u'a': 1.0,
     u'b': [1,
            2,
            3],
     u'c': True,
     u'd': u'd',
     u'e': u'e\u1234',
     u'success': True}

In the future, there will be versions of these functions that send
data as JSON.


XXX in edge-case tests, need to show that one can't traverse to
arbitrary attrs.

XXX need to talk about traversal support and nested applications.


.. [#ajax] Technically, these aren't really AJAX applications, since
   we rarely. if ever, use XML as a serialization format.

.. [#missing_resource_library_name] A custom attribute error message
   is used if this attribute is missing that tries to be more
   informative than the default attribute error.
