Ajax widgets
============

The zc.extjs.form module provides s ajax form support based on the
ExtJS form framework.

Widgets are looked up for fields and requests providing
zc.extjs.interfaces.IAjaxRequest.

Ajax widgets must implement zc.extjs.interfaces.IInputWidget. In
particular, they must provide a js_config method in addition to the
usual input-widget behavior defined by
zope.app.form.interfaces.IInputWidget. A number of widgets are defined
by the zc.extjs.widgets module.  We'll test/demonstrate those later.
There is also a base class that provides some help with implementing
IInputWidget.   It subclasses zope.app.form.InputWidget, which also
automates some of the more mundate aspects of implementing input
widgets.

zc.extjs.widgets.Base
---------------------

The zc.extjs.widgets.Base provides a basic widget implementation and
hooks that can be overridden for specific widget types.  These hooks
are:

  xtype
      This is an string attribute that, if set, should contain the ExtJS type
      name for the ExtJS widget to be used.

  widget_constructor
      This is a string attribute giving the name of a Javascript
      constructor to call.

  _toForm(v)
      Convert an application value to a value that can be marshaled to
      JSON and used to initialize the Ext widget.

  _toValue(v)
      Convert a raw value sent from the client to an application value.
  
  _is_missing(self, v)
      Return a boolean value indicating whether the given raw value is
      equivalent to the user not providing a value.

Other methods from zc.extjs.interfaces.IInputWidget may also be
overridden as needed. For example, because ExtJS doesn't send input
for unset check boxes [#noinput]_, zc.extjs.widgets.InputBool
overrides hasInput, and getInputValue.

To see how this works, we'll try some examples with the base widget:

    >>> import zope.publisher.browser
    >>> request = zope.publisher.browser.TestRequest()
    >>> import zc.extjs.widgets
    >>> import zope.schema
    >>> f = zope.schema.TextLine(
    ...    __name__='f', title=u'label', description=u'hint')
    >>> w = zc.extjs.widgets.Base(f, request)
    >>> w.required, w.hasInput(), w.hasValidInput()
    (True, False, False)

    >>> w.getInputValue()
    Traceback (most recent call last):
    ...
    MissingInputError: ('field.f', u'label', None)

    >>> from pprint import pprint
    >>> pprint(w.js_config(), width=1)
    Traceback (most recent call last):
    ...
    ValueError: Neither xtype nor widget_constructor are defined.

Oops, let's make this a text widget. Normally we'd do this in a widget
class. We'll just hack the widget instance. :)

    >>> w.xtype = 'textfield'
    >>> pprint(w.js_config(), width=1)
    {'fieldHint': u'hint',
     'fieldLabel': u'label',
     'id': 'field.f',
     'itemCls': 'zc-required-field',
     'name': 'field.f',
     'xtype': 'textfield'}

We can also (or instead) provide a widget constructor:

    >>> w.widget_constructor = 'my.widget.constructor'
    >>> pprint(w.js_config(), width=1)
    {'fieldHint': u'hint',
     'fieldLabel': u'label',
     'id': 'field.f',
     'itemCls': 'zc-required-field',
     'name': 'field.f',
     'widget_constructor': 'my.widget.constructor',
     'xtype': 'textfield'}
   
Let's add some data to the request:

    >>> request.form['field.f'] = 'xxx'
    >>> w.required, w.hasInput(), w.hasValidInput()
    (True, True, False)

    >>> w.getInputValue()
    Traceback (most recent call last):
    ...
    WidgetInputError: ('f', u'label', xxx <type 'unicode'>)

    >>> request.form['field.f'] = u'xxx'
    >>> w.required, w.hasInput(), w.hasValidInput()
    (True, True, True)

    >>> w.getInputValue()
    u'xxx'

Let's try overriding some methods:

    >>> w._toValue = lambda raw: raw+' cooked'
    >>> w._toForm = lambda v: v[:-7]
    >>> w._is_missing = lambda raw: raw == u'xxx'

    >>> w.required, w.hasInput(), w.hasValidInput()
    (True, True, False)

    >>> w.getInputValue()
    Traceback (most recent call last):
    ...
    MissingInputError: ('field.f', u'label', None)

    >>> request.form['field.f'] = u'foo'
    >>> w.required, w.hasInput(), w.hasValidInput()
    (True, True, True)

    >>> w.getInputValue()
    u'foo cooked'

    >>> pprint(w.js_config(), width=1)
    {'fieldHint': u'hint',
     'fieldLabel': u'label',
     'id': 'field.f',
     'itemCls': 'zc-required-field',
     'name': 'field.f',
     'widget_constructor': 'my.widget.constructor',
     'xtype': 'textfield'}

    >>> w.setRenderedValue(w.getInputValue())
    >>> pprint(w.js_config(), width=1)
    {'fieldHint': u'hint',
     'fieldLabel': u'label',
     'id': 'field.f',
     'itemCls': 'zc-required-field',
     'name': 'field.f',
     'value': u'foo',
     'widget_constructor': 'my.widget.constructor',
     'xtype': 'textfield'}


.. [#noinput] Another way we might handle widgets that don't send data
   on certain inputs would be to add extra hidden fields. This is
   might be be something we do or allow in the future.

